/*
	JS/JAVA : 객체 지향 [oop : Object Oriented Programming ]
		 객체란 ? 사전적인 정의로는 실제 존재하는 것을 말한다.
		 * 컴퓨터 과학에서 객체 또는 오브젝트는 클래스에서 정의한 것을 토대로 
		 메모리에 할당된 덧으로 프로그램에서 사용되는 데이터 또는 식별자에 의해 참조되는 공간을 의미하며
		 변수, 자료구조, 함수 또는 메소드가 될 수 있다.

		클래스 = 사전적인 정의
		객체 = 실제 존재하는 것 / 토대로 메모리에 할당된 것
		
		1. 정의 : 세상에 있는 모든 것(형태)들을 컴퓨터 세상으로 옮기는 것 (코드화 시키는 것)
			대량이 되어야 하고 자동이 되어야 하고 돈이 되어야 함. 수익성이 있어야 한다는 것 !!
			객체지향 프로그래밍이 적합 -> 미리 설계 (클래스) -> 컴퓨터에 설계를 주입해서 
			-> 설계 기반으로 어떤 형태를 생성한다.
			ex) 현대에서 소나타를 만든다.
				공장 = 클래스 생성 -> 소나타 생성 설계 기준
				A 소나타 = 객체 , B 소나타 = 객체 
			ex) 붕어빵 
				붕어빵 틀 = 클래스 
				붕어빵 1개 = 객체	
			ex) 30평형 000아파트
				아파트 도면도 = 클래스 
				302호 = 객체 , 303호 = 객체
			ex) 23년형 신형 LG냉장고
				냉장고 설계도 = 클래스 
				우리집(객체)안에 냉장고(객체)가 들어갈 수 있다!!!!!!!!!!!!!!!!!
				-> 우리집(객체[냉장고(객체)])  
			** 이렇게 쪼개서 모듈 단위로 개발을 하기 때문에 유지보수가 편하다. (분업)
			** 다형성이 존재해서 금호타이어쓰다가 다른 미쉘린타이어를 써도 되는...?
		2. 목적 : 
			1. 형태를 코드화 하면 자동화, 대량화가 가능하다. 컴퓨터는 피로도가 없으니까 
			2. 객체 특징 = JAVA
				1. 모듈단위의 개발 (분업화)/ 유지보수 / 설계관리 복잡도가 높을 수 밖에 없긴 하다.
				2. 다형성( 다양한 형태 성질 )이 있다. / 호환가능
		
		
		※ JS 기준 문법
			JSON : JavaScript Object Notation
			1. JS 메모리
				1. 변수 = 데이터
				2. 상수 = 데이터
				3. 배열 = [데이터1, 데이터2, 데이터3]
					- 배열의 단점 : 인덱스로 분류하기 때문에 설계자가 아니면 안에 데이터가 무엇인지 바로 식별하기 어렵다.
					ex) 유재석/강호동/신동엽 3명의 회원(정보: 아이디, 비밀번호, 이름, 주소 등등)
						1번 방법 : 정보 유형별 분류
							아이디배열 = []
							비밀번호배열 = []
							이름배열 = []
							주소배열 = []
							등등	
						2번 방법 : 인덱스로 분류
							회원배열 = ['qwe', '123', '유재석', '안산', 'asd', '456', '강호동',' '수원' 등등]	
						3번 방법 : 객체별 분류
							유재석배열 = []
							강호동배얼 = []
							신동엽배열 = []
				4. 객체 = { }
					- 사용목적 : 서로다른 데이터 유형(속성) 들을 한곳에 저장 / 묶음
					- 형태 : 속성명을 넣을 수 있어서 데이터를 식별하는것이 쉬움.
						let 객체명 = {속성명 : 데이터, 속성명 : 데이터, 속성명 : 데이터, 등등}
						객체 방법 
						 	let 회원1 = { 아이디 : 'qwe', 비밀번호 : '123', 이름 : '유재석', 주소 : '안산' }	
							let 회원2 = { 아이디 : 'asd', 비밀번호 : '456', 이름 : '강호동', 주소 : '수원' }	
							let 회원3 = { 아이디 : 'zxc', 비밀번호 : '789', 이름 : '신동엽', 주소 : '안양' }	
					- 선언 :
						키워드 객체명 ={
							속성명 : 데이터,
							속성명 : 변수,
							속성명 : 상수,
							속성명 : 배열,
							속성명 : 함수
						} 마지막에는 ,(쉼표) 생략 ! 
				5. 객체 호출
					1. 객체 전체 : 객체명
					2. 객체내 특정 속성 호출 : .
						 내장 함수를 쓸때 
						 .접근연산자[ 객체 속성 접근(호출) 해서 데이터 호출]
				6. 객체 내 속성값 [변경]
					객체명.속성명 = 새로운값
				7. 객체 내 속성값 [추가]
					객체명.새로운속성명 = 데이터;
				8. 객체 내 속성 [삭제]
					delete 객체명.속성명;
				9. 여러개의 객체 -> 관리 ( 배열 / 리스트 이용 ) <----------------> JSON 형태
					회원객체1, 1번게시물객체, 회원객체2. 2번게시물객체
					let 회원객체배열 = [ 회원객체1, 회원객체2 ]
					let 게시판배열	= [ 1번게시물객체, 2번게시물객체 ]
				
			
 */

 
 //1. 객체의 선언
 let 객체1 = { 아이디: 'qwe', 비밀번호: '123', 이름: '유재석' }
   // vs
 let 배열1 = ['qwe','123','유재석']
 
 //2. 객체의 호출
 console.log( 객체1 ) 			// 객체1의 모든 정보 호출
 console.log( '아이디 속성 호출 : ' + 객체1.아이디 ) 		// 객체1의 아이디 속성만 호출
 console.log( '비밀번호 속성 호출 : ' + 객체1.비밀번호 )		// 객체내 속성명 알고 있으면 데이터 호출 가능하다.
  // console : 내장객체 	-> console 객체에서 log() 함수 호출
  // document : 내장객체 	-> document 객체에서 querySelector() 함수 호출
  //    vs
 console.log( 배열1[0])
 
 //3. 객체의 속성 내 데이터 변경 
 객체1.비밀번호 = '123456'   // [변경] 객체 내 비밀번호 속성 호출해서 새로운 데이터 대입
 
 //4. 객첸 내 속성 추가
 객체1.주소 = '안산'; 		// [추가] 객체 내 주소 속성이 없으므로 호출이 아닌 추가되서 값 대입
 console.log ( 객체1 )
  
 //5. 객체 내 속성 삭제
 delete 객체1.주소;		// [삭제] 객체 내 속성이 삭제되면 데이터도 같이 삭제
 console.log ( 객체1 )
 
 //6. 여러개의 동일한 객체유형(속성명)를 하나의 배열에 저장 
 let 객체2 = { 아이디: 'asd', 비밀번호: '456', 이름: '강호동' }
 let 객체3 = { 아이디: 'zxc', 비밀번호: '789', 이름: '신동엽' }
 let 회원객체배열 = [ 객체1, 객체2, 객체3 ]
 
 
 // !!!!!! :  JSON ----------> 서로 다른 (웹/앱 과련)언어들 간의 데이터 구조 형태 ( 통신을 위한 공통언어? 인듯 )
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 